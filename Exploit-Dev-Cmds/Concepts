STACK

EIP is the Instruction Pointer. The CPU executes the instruction which is at the memory address and increments its value, then 
moves to the next instruction. 

ESP is the Stack Pointer. Stack is a LIFO (Last In First Out) and when a value is pushed onto the stack, the value of the ESP is 
decremented. 

EIP goes from low to high memory while ESP goes from high to low memory. If EIP is bigger, than ESP, there is no problem as they 
are moving away from each other. However if EIP is lower than ESP, a problem can arise as they go toward each other and the the 
program code might change if ESP reaches EIP.

The solution is to set the ESP above the EIP. When we jump to the beginning of the shellcode, we can push the value of EAX, 
then pop this value into ESP. A couple NOP operation might also be necessary.

===================================================================================================================================

CONDITIONAL JUMP (JA SHORT)

(Hex Code)       (OpCode)
77 21       =    JA SHORT <current address + 21> (<-- denoted as rel21)
-----------------------------------------------------------
So for example, if:
EIP = 1035fe36 which contains hex code: 77 21 (2 bytes)
Then:
Current address = 1035fe38 (note that EIP is not 36, but 38)
And:
1035fe38 + 21 = 1035fe59

So if CF and ZF are set to 0, EIP will JUMP to address: 1035fe59

===================================================================================================================================
ZERO FLAG (Z): Set if the result is zero. 
If after an arithmetic instruction the number left in the register or memory area which is the subject of the instruction is zero
then this flag is set. Often you just need to do a simple comparison of two values without changing them. In that case you can use
the instruction CMP. CMP does a pretend SUB without actually changing the values given to it as operands. For example:-

CMP EAX,33h      ;set zero flag if eax=33h, but don't change eax
SUB EAX,33h      ;set zero flag if eax=33h (eax now 33h less)
CMP EAX,EDX      ;set zero flag if eax=edx
CMP EAX,[VALUE]  ;set zero flag if eax=the number in VALUE

 If the DEC ESP instruction caused ESP to be set to 0xFFFFFFFF then the ZF is set. Since that's super unlikely to happen, the ZF 
 is unset, and we take our conditional jump. ZF being set would indicate the previous instruction resulted in a zero value. Since
 the value of ESP is probably always going to be a large-enough non-zero number, DEC ESP should guarantee ZF=0. Incrementing any 
 register should result in ZF=0 (unless the register contains 0xFFFFFFFF), and the JZ or JNZ instructions can probably be used 
 more reliably, since it only checks against ZF.

CARRY FLAG (C): Set if the result of the instruction has gone beyond the limit of the data size (ie. a "carry" has occurred). 
For example suppose in an 8 bit instruction the value of 1 is added to 255. This can't make 256 since 255 is the data limit for 
a byte. So the result will be 0, but the carry flag will be set. Similarly suppose in an instruction the value of 4 is 
subtracted from 2. Again this causes the carry flag to be set because the result has gone below zero which is the lower limit of
the data size. 

===================================================================================================================================
SEH EXAMPLE

00B7FFDC 41414141				<--seh
41414141 ***CORRUPT ENTRY ***	<--nseh

nseh = "BBBB"
seh  = "CCCC"
buffer = "GMON /.:/" + "A"*3495 + nseh + seh + "D"*(5000 - 3495 - 4 - 4)

00B7FFDC 43434343				<--seh
42424242 ***CORRUPT ENTRY ***	<--nseh

We overwrite seh with a POP POP RET which returns us to the 4 bytes before seh which, is nseh.
SHIFT+F9 will pass the exception and EIP will be overwritten with 43434343

===================================================================================================================================
SEARCHING FOR EGG

In Debugger, we can search for our egg like an egghunter would by clicking 'M' to load the memory map, Right-click > Search
ASCII: TOOW
Hex+04 54 30 30 57
OK

===================================================================================================================================
LOGICAL OPERATORS

AND: Both inputs must be true for the output to be true. AND is used for addition and decision making.

 -----------
  A B Output
 -----------
  0 0    0
  0 1    0
  1 0    0
  1 1    1

OR: Both inputs must be false for the output to be false. OR is used in decision making. Both AND and OR are used for Bit Masking. Bit masking is used to pick individual bits out of a byte or to set particular bits in a byte. OR is used to set bits to one. AND is used to set bits to nought. AND is used to test if bits are one. OR is used to test if bits are nought.

 -----------
  A B Output
 -----------
  0 0    0
  0 1    1
  1 0    1
  1 1    1

XOR: If the bits in a graphical image are XORed with other bits a new image appears. If the XORing is repeated the image disappears again. This is how the mouse and text cursors get moved around the screen. XOR is combined with AND for use in addition. XOR detects if the inputs are equal or not.

 -----------
  A B Output
 -----------
  0 0    0
  0 1    1
  1 0    1
  1 1    0

NAND: NAND is really AND followed by NOT. Electronic circuits are commonly built from NAND gates (circuits). Computer 
programming languages and this simulator do not provide NAND. Use NOT AND instead.

 -----------
  A B Output
 -----------
  0 0    1
  0 1    1
  1 0    1
  1 1    0

NOR: NOR is really OR followed by NOT. Electronic circuits are commonly built from NOR gates (circuits). Computer programming 
languages and this simulator do not provide NOR. Use NOT OR instead.

 -----------
  A B Output
 -----------
  0 0    1
  0 1    0
  1 0    0
  1 1    0

NOT: NOT is used to invert bits or True/False values. All the rules above had two inputs and one output. NOT has a single 
input and output.

 -----------
  A  Output
 -----------
  0     1
  1     0

===================================================================================================================================
REGISTERS

EIP is the instruction pointer. It points to (holds the address of) the first byte of the next instruction to be executed.

ESP is the stack pointer. It points to (holds the address of) the most-recently pushed value on the stack

===================================================================================================================================
LITTLE ENDIAN:
If we identify a pointer like the following:
0x77c35459 : push esp # ret | {PAGE_EXECUTE_READ} [msvcrt.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v7.0.2600.5701 (C:\WINDOWS\system32\msvcrt.dll)

Then in our exploit the address would be:
Buffer: evil = "A"*247 + "\x59\x54\xC3\x77" + "C"*749
===================================================================================================================================
JMP OPCODES:
0xeb 0x06 - Jump forward 6 bytes
0xeb 0x0c - Jump forward 12 bytes
0xeb 0xf4 - Jump backward 12 bytes
0xe9 0xe0 0xfc 0xff 0xff - Far jump back 800 bytes
0x4c 0x4c - DEC ESP, DEC ESP 
0x77 0x21 - Conditional short jump if above (CF=0 and ZF=0)
===================================================================================================================================
Negative SHORT JMP:
The first byte of a SHORT Jump is always EB and the second is a relative offset from 00h to 7Fh for Forward jumps, and from 80h to FFh for Reverse (or Backward) jumps. [Note: The offset count always begins at the byte immediately after the JMP instruction for any type of Relative Jump!]

===================================================================================================================================

ASCII Text:                                             ASCII Text:
calc.exe                                                abcdefghijkl

Split Text into groups of 4 characters:                 Split Text into groups of 4 characters:
"calc"                                                  "abcd"
".exe"                                                  "efgh"
                                                        "ijkl"

Reverse the order of the character groups:              Reverse the order of the character groups:
".exe"                                                  "ijkl"
"calc"                                                  "efgh"
                                                        "abcd"

Look on google for a ASCII to hex converter             Look on google for a ASCII to hex converter
and convert each character while maintaining            and convert each character while maintaining
the order:                                              the order:
"\x2E\x65\x78\x65"                                      "\x69\x6A\x6B\x6C"
"\x63\x61\x6C\x63"                                      "\x65\x66\x67\x68"
                                                        "\x61\x62\x63\x64"

To write these values to the stack simply add           To write these values to the stack simply add
"\x68" infront of each group:                           "\x68" infront of each group:
"\x68\x2E\x65\x78\x65" => PUSH ".exe"                   "\x68\x69\x6A\x6B\x6C" => PUSH "ijkl"
"\x68\x63\x61\x6C\x63" => PUSH "calc"                   "\x68\x65\x66\x67\x68" => PUSH "efgh"
                                                        "\x68\x61\x62\x63\x64" => PUSH "abcd"
